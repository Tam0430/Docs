### Observability 
The ability to understand and measure the state of a system based upon data generated by the system
Observability allows you to generate actionable outputs from unexpected scenarios in dynamic environment

Observability will help:
	1. Give better insight into the internal workings of a system/application
	2. speed up troubleshooting
	3. Detect hard to catch problems
	4. Monitor performance of an application
	5. Improve cross-team collaboration

#### Generic cloud provider
Working mechanism 
1. scrape interval -- 15 sec to 1 min
2. TSDB -- Time series database
3. Node exporter -- only linux--> agent --> port 9100
prometheus port number  --> 9090

#### 3 Pillars of Observability
How do we accomplish observability
	1. [Logging]
	2. [[Metrics]]
	3. [[Traces]]
[[Logging]]
Logs are records of events that have occurred and encapsulate information about the specific event
	Logs are comprised of:
	- Timestamp of when the log occurred
	- Message containing information
Logs are the most common form of observation produced by systems

[[Traces]]
Traces - allow you to follow operations as they traverses through various systems & services
So we can follow an individual request and see it flow through our system hop by hop
Traces help us connect the dots on how processes and services work together
![[Pasted image 20250104103253.png]] 
![[Pasted image 20250104103456.png]]


[[Metrics]]
Metrics provide information about the state of a system using numerical values
* CPU Load
*  Number of open files
*  HTTP response times
*  Number of errors
The data collected can be aggregated over time and graphed using visualisation tools to identify tools to identify trends over tine.
Metrics contain 4 pieces of information:
1. Metric name
2. Value - most recent or current value of the metric 
3. Timestamp for the metric
4. Dimensions - additional information about the metric
![[Pasted image 20250104122935.png]]

Prometheus is a monitoring solution that is responsible for collecting and aggregating metrics

##### Service Level Indicator(SLI)
   Quantitative measure of some aspect of the level of service that is provided
Common SLIs:
* Request Latency
* Error Rate
* Saturation
* Throughput
* Availability
Not all metrics for good SLIs. You want to find metrics that accurately measure a  user's experience

#### Service Level Object(SLO)
  Target value or range for an SLI

| SLI          | SLO             |
| ------------ | --------------- |
| Latency      | Latency < 100ms |
| availability | 99.9% uptime    |
SLOs should be directly related to the customer experience. The main purpose of SLO is to quantify reliability of a product to a customer

#### Service Level Agreement(SLA)
  Contract between a vendor and user that guarantees a certain SLO
  The consequences for the meeting any SLO can be financial based but can also be variety of other things as well

# Prometheus
 Its an open-source monitoring tool that collects metrics data, and provide tools to visualise the collected data
In addition, Prometheus allows you to generate alerts when metric reach a user specification threshold
Prometheus collects metrics by scraping targets who expose metrics through an HTTP endpoint
Scraped metric are then stored in a time series database which can be queried using Prometheus built-in query language PromQl
#### what kind of metrics can Prometheus Monitor?
- CPU/Memory Utilization
- Disk space
- Service Uptime
- Application specific data
	- Number of exceptions
	- Latency
	- Pending Requests
Prometheus is designed to monitor time-series data that is numeric
What type of data should prometheus ***not*** monitor
- Events 
- System Logs
- Traces
# Prometheus Architecture 
![[Pasted image 20250104130740.png]]
###### Exporter  
- just little mini process that run on your targets that are responsible for serving up the metrics
- These exporters are responsible for taking internal data and converting it into a metric that prometheus will understand . .
- Most systems by default don't collect metrics and expose them on an HTTP endpoint to be consumed by a prometheus server
- Exporter collect metrics and expose them in a format prometheus expects
![[Pasted image 20250104175246.png]]


Prometheus using  Pull data request 
If you want to use the **push** data for some addition scenario you need to use external Push gateway

##### Service Discovery
  Service discovery is all about providing a list of targets for Prometheus escape so that you don't have code those values.
##### Alert Manager:
  it handle all of the SMS, the email, the SMTP integration it can send the notification to the end user
![[Pasted image 20250104174937.png]]

### Prometheus Installation systemd
	sudo useradd --no-create-home --shell /bin/false prometheus
config Directory store the prometheus.yaml file `sudo mkdir /etc/prometheus`
`sudo mkdir /var/lib/prometheus`  store the all of the data
`sudo chown prometheus:prometheus /etc/prometheus`
`sudo chown prometheus:prometheus /var/lib/prometheus`
`wget <prometheus pkg url>`
`tar xvfz prometheus-x.xx.xx.linux-amd64.tar.gz`
`sudo cp prometheus /usr/local/bin`
`sudo cp promtool /usr/local/bin`
`sudo cp -r consoles /etc/prometheus`.
`sudo cp -r console_libraries /etc/prometheus`
`sudo cp prometheus.yaml /etc/prometheus/prometheus.yaml`
gave the  permission to prometheus users to this files 
`sudo -u prometheus /usr/local/bin/prometheus \`
   `--config.file /etc/prometheus/prometheus.yaml \`
   `--storage.tsdb.path /var/lib/prometheus`
   `--web.console.templates=/etc/prometheus/console \`
   `--web.console.libraries=/etc/prometheus/console_libraries`

`sudo vi /etc/systemd/system/prometheus.service`
![[Pasted image 20250105195918.png]]

`sudo systemctl deamon-reload`
`sudo systemctl start prometheus`
`sudo systemctl enable prometheus`
`sudo systemctl status prometheus`
`crul http://localhost:9090`

##### Node Exporter Installation:-
This is collecting metrics tool on a Linux Host 
`wget https://github.com/prometheus/node_exporter/releases/download/v1.8.2/node_exporter-1.8.2.linux-amd64.tar.gz`
`tar xvf node_exporter`
`cd node_exporter`
`./node_exporter`
`curl localhost:9100/metrics`  OR `http://localhost:9100/metrics`  on web browser
#### *Node exporter installation on systemd*
`sudo cp node_exporter /usr/local/bin`.
`sudo useradd --no-create-home --shell /bin/false node_exporter`
`sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter`
`sudo vi /etc/systemd/system/node_exporter.service`
![[Pasted image 20250105201301.png]]
`sudo systemctl daemon-reload`
`sudo systemctl start node_exporter`
`sudo systemctl enable node_exporter`
`sudo systemctl status node_exporter`

### Prometheus configuration
![[Pasted image 20250105203113.png]]

| `job_name: 'nodes'`                                 | Define a job with a name of nodes                                     |
| --------------------------------------------------- | --------------------------------------------------------------------- |
| `scrape_interval: 30s`                              | Metrics should be scraped every 30s.                                  |
| `scrape_timeout: 3s`                                | Timeout of a scrape is 3s                                             |
| `scheme: https`                                     | Use HTTPS instead of default HTTP.                                    |
| `metrics_path: /stats/metrics`                      | Scrape path should be changed from default /metrics to /stats/metrics |
| `static_configs:`<br>     `- targets: [IP_address]` | scrape targets at the IP address                                      |

#### Node Exporter TLS (Authentication/Encryption):-
Create a openssl certificate on a node using the openssl command
 set up the TLS process please check this below link
https://ruan.dev/blog/2021/10/10/setup-basic-authentication-on-node-exporter-and-prometheus

#### Prometheus Metrics:
![[Pasted image 20250106210606.png]]

###### Time Stamp:-
When Prometheus scrapes a target and retrieves metrics, it also stores the time at which the metric was scraped as well
The ***timestamp*** will look like this: `1668242900`
This is called a ***unix timestamp***, which is the number of seconds that have elapsed since Epoch(January 1st 1970 UTC)

##### Prometheus Time Series:
Stream of timestamped values sharing the same metric and set of labels

Metrics have a TYPE and HELP attribute
HELP -- description of what the metric is
TYPE -- Specifies what type of metric(counter, gauge, histogram, summary)
![[Pasted image 20250106211716.png]]
***counter*** 
- How many times did x happen
- Number can only increase
EX:-  Total requests, Total Exceptions, Total of job executions
***Gauge***
- What is the current value of x
- Can go up and Down
Ex:- Current CPU Utilisation, Available system memory, number of concurrent request
***Histogram***
- How long or how big something is
- Groups observations into configurable bucket sizes(<,>)
![[Pasted image 20250106213041.png]]
***Summary***
- Similar to histograms (track how long or how big)
- How many observations fell below x
![[Pasted image 20250106213259.png]]

***Labels***
- Labels are Key-value pairs associated with a metric
- Allows you to split up a metric by a specified criteria
- Metric can have more then one label
- ASCII letters, numbers, underscores
- Must match regex [a-z,A-Z,0-9_]*
Every metric is assigned 2 labels by default(***instance*** and ***job***)
![[Pasted image 20250106214448.png]]

#### Prom tools:
 its a utility tool shipped with prometheus that can be used to:
 - Check and validate configuration
	 - validate prometheus.yml
	 - validate rule files
 - validate metrics passed to it are correctly formatted
 - can perform queries on a prometheus server
 - Debugging & profiling a prometheus server
 `promtool check config /etc/prometheus/prometheus.yml`

#### Container Metrics:
- Metrics can also be scraped from containerised environments 
- Docker Engine metrics 
- Container metrics using cAdvisor

##### Docker Engine metrics :-(if you want information of Docker Engine host )
`vi /etc/docker/daemon.json`
![[Pasted image 20250106220844.png]]
`sudo systemctl restart docker`
`curl localhost:9323/metrics`
Prometheus config file add new job like below
![[Pasted image 20250106221111.png]]

##### cAdvisor Metrics(if you want information of containers )
![[Pasted image 20250106221357.png]]
Prometheus config add new job for cAdvisor
![[Pasted image 20250106221513.png]]


| ***Docker Engine metrics***         | ***cAdvisor metrics***                         |
| ----------------------------------- | ---------------------------------------------- |
| How much cpu does docker use        | How much cpu/mem does each container use       |
| Total number of failed image builds | Number of processes running inside a container |
| Time to process container actions   | Container up time                              |
| No metrics specfic to a container   | Metrics on a per container basics              |
### PromQL
- Short for prometheus Query Language
- Main way to query metrics within prometheus 
- Data returned can be visualized in dashboards
- Used to build alerting rules to notify administrators.
###### ***A PromQL expression can evaluate to one of four types:
1. String - a simple string value (currently unused)
2. Scalar - a simple numeric floating point value
3. Instant Vector - set of time series containing a single sample for each time series, all sharing the same timestamp
4. Range Vector - set of time series containing a range of data points over time for each time series.
##### ***Label Matchers***:-
`=`    Exact mach on a Label value
- Return all time series from node1
	$ node_filesystem_avail_bytes{instance="node1"}
  instance="node1" will match all time series from node01
  
`!=`  Negative equality matcher - return time series that don't have the label.
- Return all time series where device is not equal to "tmpfs"
	$ node_filesystem_avail_bytes{device!="tmpfs"}
  != matcher will ensure that only devices that are not "tmpfs"
  
`=~`  Regular expression matcher - matches time series with labels match regex
- Return all time series where device starts with "/dev/sda" (sda2&sda3)
	$ node_filesystem_avail_bytes{device=~"/dev/sda.* "}
  To match anything that starts with /dev/sda, a regex "/dev/sda.* " will need to be used 

`!~`  Negative regular expression matcher 
- Return all time series where mountpoint does not start with "/boot"
	$ node_filesystem_avail_bytes{mountpoint!~"/boot.* "}
  To match anything that starts with "/boot", a regex "/boot.* " will need to be
###### ***Multiple Selectors:-
- Return all time series from node1 without a "device=tmpfs"
	$ node_filesystem_avail_bytes{instance="node1", device!="tmpfs"}
  Multiple selectors can be used by separating them by a comma
###### ***Range Vector Selectors:-
- Return all the values for a metric over a period of time
	$ node_arp_entries{instance="node1"}[2m]
  Return node_arp_entries metric data for the past 2 minutes.

Time Series converter:
  epoach & unix timestamp conversion tools --> website

##### PromQL has 3 logical operators
1. OR
2. AND 
3. Unless

#### Vector Matching
- one-to-one vector matching - Every element in the vector on the left of the operator tries to find a single matching element on the right
- Many-to-One vector matching - Each vector elements on the one side can match with multiple elements on the many side


##### Kube-State-Metrics
- To collect cluster level metrics(pods, deployments, etc) the kube-state-metrics container must be deployed
##### Node Exporter
Every host should run a node_exporter to expose cpu, memory, and network stats
We can manually go in an install a node_exporter on every node
Better option is to use a kubernetes daemonSet -pod that runs on every node in the cluster
##### Service Monitoring
- Service monitor define a set of targets for prometheus to monitor and scrape 
- They allow you to avoid touching prometheus configs directly and give you a declarative kubernetes syntax to define targets
- 

